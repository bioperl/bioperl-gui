# $Id$
=head1 NAME

Bio::Tk::SeqCanvas.pm - (v2.0) Graphical display of SeqI objects


=head1 AUTHORS

Mark Wilkinson (mwilkinson@gene.pbi.nrc.ca), David Block (dblock@gene.pbi.nrc.ca)
Plant Biotechnology Institute, National Research Council of Canada.
Copyright (c) National Research Council of Canada, May, 2001.

=head2 DISCLAIMER

Anyone who intends to use and uses this software and code acknowledges and
agrees to the following: The National Research Council of Canada (herein "NRC")
disclaims any warranties, expressed, implied, or statutory, of any kind or
nature with respect to the software, including without limitation any warranty
or merchantability or fitness for a particular purpose.  NRC shall not be liable
in any event for any damages, whether direct or indirect,
consequential or incidental, arising from the use of the software.

=head2 DESCRIPTION and ACKNOWLEDGEMENTS

Creates an interactive scalable/zoomable map of all features and
subfeatures of Bio::SeqI compliant and GeneStructureI compliant objects.
Selecting single and multiple map objects is handled in the object
itself: left-mouse click to select, SHIFT-left-mouse to select
multiple. All other Tk Events are passed back up to the MainWindow
object and can be trapped/bound by the user as they see fit.  Colors
and axis-offsets of mapped objects are assigned based on the "source"
tag of SeqFeature::Generic objects, and by the ordinal transcript number
of Gene:;TranscriptI compliant objects. These are assigned "on the fly" based on
whatever is contained in the BioSeq object provided.  The maps re-size
on the fly to accomodate newly added features.

This module requires an updated version of Gregg Helt's original
BioTkPerl modules (version 0.82) which are available from BioPerl.  The
original BioTkPerl (version 0.80) is Copyright (c) Gregg Helt, 1995;
Version 0.82 was generated by Mark Wilkinson, PBI-NRC, May., 2001.

Zooming routines/events in this module are conceptually based on the
Zoom routines from Genotator (Copyright (c) 1996, The Regents of the
University of California.  Harris, N.L. (1997), Genome Research
7 (7):754-762)

=head2 CONTACT

Mark Wilkinson (mwilkinson@gene.pbi.nrc.ca) and Dave Block (dblock@gene.pbi.nrc.ca)

=head1 SYNOPSIS

 # To create a BioSeq map and return a handle to the map object:
 use Tk;
 use Bio::SeqIO;
 use Bio::SeqFeature::Gene::Exon;
 use Bio::SeqFeature::Gene::Transcript;
 use Bio::SeqFeature::Gene::GeneStructure;
 use SeqCanvas2;
 Begin();
 MainLoop;

 sub Begin {

 # set up the Tk Windows
  	
 my $MW = MainWindow->new (-title => "Map Of BioSeq Object");
 my $Frame = $MW->Frame()->pack(-side => 'top');
 my $Frame2 = $MW->Frame()->pack(-side => 'top');
 my $lblSysMess = $MW->Label()->pack(-side => 'bottom', -fill => 'both');

 # create a BioSeq object
  	
 my $SIO = Bio::SeqIO->new(-file=> 'genbankfile.gb', -format => 'genbank');
 my $SeqObj = $SIO->next_seq();

 # Draw the Map
 my $axis_length = 800;  # how large I want the final map to be
 $MapObj = Bio::Tk::SeqCanvas2->new(
 	$axis_length,
 	$Frame,
 	$lblSysMess,
 	$SeqObj,
 	-orientation => 'horizontal',
 	label => 'primary_tag',
 	width => 200,
 	);
 }

=head1 WIDGET TAGS

Each map-widget has several "reliable" tags attached to it. These tags
are FIDxxxx, Source and Strand, Type, and Canvas, where:

=over

=item *

FIDxxxx is the unique identifier for that particular map-widget over all maps (even in multiple windows)

=item *

Source is derived from the "source" tag of the SeqFeature object this widget represents

=item *

Strand is derived from the "strand" tag of the SeqFeature object, converted into the GFF standard of +/-/. to represent the three possible strand values.

=item *

Type isthe feature type, derived from the primary_tag of the SeqFeature object

=item *

Map is either 'draft' or 'finished' to represent an object on the white or blue maps respectively

=back

So for example, a map widget might have the tags :

	FID22354 (no space)
	Source GeneMarkHMM (single space separated)
	Strand + (single space separated)
	Type exon ( " )
	Canvas draft ( " )

If your BioSeq Features are being derived from an external database,
it is possible to also include the unique index number of that
database entry as a fourth tag on the associated map-widget. To do so,
create your SeqFeature objects with an additional tag "id", where the
unique databse index number is the value of this tag. This index
number is then attached to the widget as a fourth tag with the form:

	DB_ID xxxxx (x's represent the unique index value)

The values of these three/four tags can be retrieved for any selected
object using the getSelectedTags function (see below) in order to
relate mapped objects back to their original database entries.  Using
the selectWithTag or recolorWithTag routines (see below) requires that
you pass the **full tag** as the desired selection (eg. pass "Source
GeneMarkHMM" not just "GeneMarkHMM")

=cut

=head1 CODE EXAMPLES:  Adding/Binding Features

 SeqCanvas is a dynamic map, allowing features to be added or removed
 after the object has been created.  In addition, events occurring
 on this canvas can be externally bound and assigned to subroutines
 to allow the canvas to feed information out to an external program
 for further processing.

 Some code examples are below; these can be added into the Begin()
 subroutine in the synopsis to see how they work:
 	
    # MAPPING SIMPLE GENERIC FEATURES
    #________________________________
    # make six arbitrary features and map them
    # if this is added into the Synopsis routine
    # you will see that these features are labelled
    # using their "author" tag values
    my $x = 1;
    while ($x < 6){
    my $feat = new Bio::SeqFeature::Generic (
    	-start => 5000*$x,
    	-end => 6000*$x,
       -strand => -1,
       -primary => 'Unusual_feature',
       -source => "example$x",
       -score  => 1000,
       -tag    => {new => 1,
       			author => 'someone_$x',
       			sillytag => 'this is silly!'}
       			);
    my ($FID) = $MapObj->mapFeatures(undef, [$feat]);
    ++$x;
    }


    # MAPPING GeneStructureI COMPLIANT FEATURES
    #__________________________________________
    # first create the feature 	
    my $exon1 = new Bio::SeqFeature::Gene::Exon (-start => 3300, -end => 4000, -primary_tag => "exon", -source => "genscan", -strand => -1);
    my $exon2 = new Bio::SeqFeature::Gene::Exon (-start => 4400, -end => 6000, -primary_tag => "exon", -source => "genscan", -strand => -1);
    my $exon3 = new Bio::SeqFeature::Gene::Exon (-start => 3000, -end => 4000, -primary_tag => "exon", -source => "genemark", -strand => -1);
    my $exon4 = new Bio::SeqFeature::Gene::Exon (-start => 5000, -end => 6000, -primary_tag => "exon", -source => "genemark", -strand => -1);
    my $polyA = Bio::SeqFeature::Generic->new(-start => 2500, -end => 2800, -primary_tag=> "polyA", -source => "polyA-scan", -strand => -1);
    my $prom = Bio::SeqFeature::Generic->new(-start => 6200, -end => 6500, -primary_tag=> "promoter", -source => "prom-find", -strand => -1);
    my $transcript = Bio::SeqFeature::Gene::Transcript->new(-start => 2500, -end => 6500, -primary_tag => "transcript", -source => "transcript", -strand => -1);
    my $transcript2 = Bio::SeqFeature::Gene::Transcript->new(-start => 2500, -end => 6500, -primary_tag => "transcript", -source => "transcript", -strand => -1);
    $transcript->add_promoter($prom);
    $transcript->add_exon($exon1, 'initial');
    $transcript->add_exon($exon2, 'terminal');
    $transcript->poly_A_site($polyA);
    $transcript->source_tag("cDNA_evidence");
    $transcript2->add_promoter($prom);
    $transcript2->add_exon($exon3, 'initial');
    $transcript2->add_exon($exon4, 'terminal');
    $transcript2->poly_A_site($polyA);
    $transcript2->source_tag("EST_evidence");
    my $Gene = Bio::SeqFeature::Gene::GeneStructure->new(-start => 2500, -end => 6500, -strand => -1, -primary_tag => "Gene", -source => "mark");
    $Gene->add_transcript($transcript);
    $Gene->add_transcript($transcript2);
    #$Gene->add_transcript($transcript8);
    $SeqObj->add_SeqFeature($Gene);
    my ($FID) = $MapObj->mapFeatures(undef, [$Gene]);


    # BINDING EVENTS
    #_______________
    # usually you will want to bind events to the
    # MainWindow ($MW) object.
    #

    $MW->bind("<Button-1>" => sub {
     my ($FID, $strand, $source, $type, $canvas, $DB_ID) = $MapObj->getSelectedTags;
      print "Feature ID = $FID\n";
      print "Source = $source\n";
      print "Primary_tag = $type\n";
      print "Strand = $strand\n\n";
    });

    $MW->bind("<Motion>" => sub {
     my @FIDs = @{$MapObj->getIDsWithTag(["Mouse_over"])};
      # do whatever here, for example:
      # foreach my $ID(@FIDs){print "id=$ID\n"}
    });	

=cut
 	
package Bio::Tk::SeqCanvas;
use strict;
use Tk;
use Carp;
use Bio::Tk::AnnotMap;
use Tk::widgets qw(ColorEditor);
use Bio::SeqI;
use vars qw(@ISA $AUTOLOAD);
require Bio::Tk::BioTkPerl8_2; # requires version 0.82 of Gregg Helt's Bio::TkPerl (can be obtained from BioPerl website)
				      # note that this is NOT the version available directly from Berkeley!!

Tk::Widget->Construct('SeqCanvas');


@ISA=qw(Bio::Tk::AnnotMap Bio::SeqI);

$Bio::Tk::SeqCanvas::VERSION='2.0';

{
	#Encapsulated class data
#Encapsulated class data for a SeqCanvas
	my %colordef = (
		magenta => '#ee00ee',
		fuschia => '#ff00cc',
		red => '#ff1100',
		pink => '#ffdddd',
		orange => '#ffaa00',
		yellow => '#eed007',
		purple => '#bb00ff',
		darkblue => '#3300ee',
		lightblue => '#99bbee',
		turquoise => '#00ddcc',
		green => '#11dd11',
		chartreuse => '#aacc00',
		yellowgreen => '#669900',
		black => '#000000',
		brown => '#994444',
		dkgreen => '#00aa00',
		ltgreen => '#aaeeaa',
	 );
	 my @colorlist = qw(darkblue magenta dkgreen fuschia orange purple chartreuse lightblue yellowgreen turquoise green yellow brown ltgreen);
	
	
	#___________________________________________________________
	#ATTRIBUTES
    my %_attr_data = #     				DEFAULT    	ACCESSIBILITY
                  (	
                    dxa					=>  [0,           	'read/write'],  # x/y coords of the draft (d) and finished (f) canvases
                    dya  				=>  [0,           	'read/write'],
                    dxb  				=>  [0,         	'read/write'],
                    dyb  				=>  [0,         	'read/write'],
                    fxa					=>  [0,           	'read/write'],
                    fya  				=>  [0,           	'read/write'],
                    fxb  				=>  [0,         	'read/write'],
                    fyb  				=>  [0,         	'read/write'],
                    -axis_loc  			=>  [0,           'read/write'],	
                    -labelfont 			=> 	['TimesNewRoman 9 normal',		'read/write'],
                    -range				=>  [undef,			'read/write'],
                    label				=>  [undef, 		'read/write'],  # if this is defined then this is the Feature tag used to write labels on mapped objects
                    ScrollBar   		=>  [undef, 		'read/write'],
                    ZoomBar     		=>  [undef, 		'read/write'],
                    FinishedMap			=> 	[undef,			'read/write'],
                    DraftMap 			=> 	[undef,			'read/write'],
                    MapSeq				=>	[undef,			'read/write'],
                    MapFrame			=>	[undef,			'read/write'],
                    SeqFrame			=>  [undef, 		'read/write'],  # the frame to hold the sequence display
                    #SeqText				=>  [undef, 		'read/write'],  # the sequence display text box
                    ZoomFrame			=>	[undef,			'read/write'],
                    ScrollFrame 		=>  [undef, 		'read/write'],
                    DraftCanvas			=>	[undef,			'read/write'],
                    FinishedCanvas		=>	[undef,			'read/write'],
                    AnnotTextFrame  	=>  [undef, 		'read/write'],  # as below
                    AnnotTextCanvas 	=>  [undef, 		'read/write'],	# this is not used directly in SeqCanvas, but can be used by external routines to generate a third frame containing textual information beside the annotatinos (a la AceDB)
                    AnnotTextMap    	=>  [undef, 		'read/write'],  # as above
                    DraftLabelCanvas	=>	[undef,			'read/write'],
                    FinishedLabelCanvas	=>	[undef,			'read/write'],
                    InitialFinishedLabels=> [['gene'], 		'read/write'],
                    InitialSources		=>  [['hand_annotation'],		'read/write'],
                    Colors				=>	[{},			'read/write'],  # the colors associated with each source  $Colors{$source} = "color"; Class property
                    colordefs 			=>	[\%colordef,    'read/write'],
                    colorlist 			=> 	[\@colorlist,	'read/write'],
                    current_offsets		=>	[{}, 			'read/write'],
                    zoom_triggers 		=>	[{},				'read/write'],
                    min_zoom	 		=>	[1,				'read/write'],
                    max_zoom	 		=>	[2,				'read/write'],
                    zoom_ratio 			=>	[1,				'read/write'],
                    zoom_level 			=>	[0,				'read/write'],
                    current_loc 		=>	[1,				'read/write'],
                    finished_total_offset=>	[undef,			'read/write'],   # the largest offset for the finished map
                    draft_total_offset 	=>	[undef,			'read/write'],   # the largest offset for the draft map
                    width				=>	[200,			'read/write'],   # the "width" (perpendicular to the axis) of the maps at the outset
                    -orientation 		=>  ['horizontal',	'read/write'],
                    # FeatureID			=>  [0,           	'read/write'],   # this is a simple incremental counter to assign each on-map object its index within the list of $feature objects in $self->IndexedFeatureList
                    whitespace 			=>	[10, 			'read'],         # whitespace is the distance between the axis and the first widget; the default never changes
                    IndexedFeatureList 	=>	[[],				'read/write'],   # to compensate for Tk:;Canvas not being able to have a $reference as a tag element we put all $features into a list, and have the list index as a widget tag to associate widgets and their corresponding feature objects.  This list is a class property, thus a feature will have a unique indexes across all created canvases.
                    SysMess 			=>	[undef, 			'read/write'],   # this is an (optional) handle back out to a label on the top level window to send system messages
                    dragx1  			=>	[undef, 			'read/write'],
                    dragy1  			=>	[undef, 			'read/write'],
                    dragx2  			=>	[undef, 			'read/write'],
                    dragy2  			=>	[undef, 			'read/write'],
                    def_offset			=>	[10, 			'read/write'],

                    );

	my $_nextid;
	my $_nextDoffset;
    my $_nextFoffset;
    #my %offsets;     # note that these are encapsulated CLASS properties
    my %colors;      # and thus are constant from one instantiation to the next
    my $_color_pos = 0;
    my @FinishedSourceLabels;
    my @Sources;
    #_____________________________________________________________
    #METHODS, to operate on encapsulated class data

    # Is a specified object attribute accessible in a given mode
    sub _accessible  {
	my ($self, $attr, $mode) = @_;
	$_attr_data{$attr}[1] =~ /$mode/
    }

    # Classwide default value for a specified object attribute
    sub _default_for {
	my ($self, $attr) = @_;
	$_attr_data{$attr}[0];
    }

    # List of names of all specified object attributes
    sub _standard_keys {
	keys %_attr_data;
    }

    sub FinishedSources {    # for backwards compatibility
    	return \@FinishedSourceLabels;
    }

    sub DraftSources {       # for backwards compatibility
    	return \@Sources;
    }

    sub FinishedSourceLabels {
    	my ($self, @labels) = @_;
    	if (scalar @labels){@FinishedSourceLabels = @labels}
    	return @FinishedSourceLabels;
    }

    sub addFinishedSourceLabel {
    	my ($self, @labels) = @_;
    	my %sourcehash;
    	foreach my $source(@FinishedSourceLabels){$sourcehash{$source} = 1}
    	foreach my $new(@labels){$sourcehash{$new} = 1}
    	@FinishedSourceLabels = (keys %sourcehash);
    	return @FinishedSourceLabels;
    }

    sub Sources {
    	my ($self, @sources) = @_;
    	if (scalar @sources){@Sources = @sources}
        return 	@Sources;
    }

    sub addSource {
    	my ($self, @new_sources) = @_;
    	my %sourcehash;
    	foreach my $source(@Sources){$sourcehash{$source} = 1}
    	foreach my $new(@new_sources){$sourcehash{$new} = 1}
    	@Sources = (keys %sourcehash);
    	return @Sources;
    }

    sub colorlist {
    	return @colorlist
    }

    sub colordef {
    	return %colordef
    }

    sub MapArgs {
    	my ($self) = @_;
    	my %_map_args;
    	foreach my $key ($self->_standard_keys) {
    		
    		if ($key =~ /^-/) {
    			$_map_args{$key} = $self->{$key};
    		}
    	}
    	return %_map_args;
    }

    sub next_id {
		return $_nextid++;
    }

    sub next_draft_offset {
    	if (!$_nextDoffset){$_nextDoffset=2}
    	return $_nextDoffset++;     # in this case increment it
    }

    sub next_finished_offset {
    	if (!$_nextFoffset){$_nextFoffset=2}
    	return $_nextFoffset++;     # in this case increment it
    }

    sub draft_offset_pointer {
    	if (!$_nextDoffset){$_nextDoffset = 2}
    	return $_nextDoffset;       # in this case just send it as it is
    }
    sub finished_offset_pointer {
    	if (!$_nextFoffset){$_nextFoffset = 2}
    	return $_nextFoffset;       # in this case just send it as it is
    }
    #sub current_offsets {
    #	return \%offsets;
    #}
    sub current_colors {
    	return \%colors;
    }
    sub next_colorpos {
        my $pos = $_color_pos;
        ++$_color_pos;
        if (!$colorlist[$_color_pos]){$_color_pos = 0}    # if we are beyond the end of the colorlist then return the pointer to zero
        return $pos;
    }


}

sub subseq {
    my ($self,@args)=@_;
    return $self->MapSeq->subseq(@args);
}

sub start {return $_[0]->MapSeq->start; }
sub end   {return $_[0]->MapSeq->end;   }

sub DESTROY {}

sub AUTOLOAD {
    no strict "refs";
    my ($self, $newval) = @_;

    $AUTOLOAD =~ /.*::(\w+)/;

    my $attr=$1;
    if ($self->_accessible($attr,'write')) {

	*{$AUTOLOAD} = sub {
	    if ($_[1]) { $_[0]->{$attr} = $_[1] }
	    return $_[0]->{$attr};
	};    ### end of created subroutine

###  this is called first time only
	if ($newval) {
	    $self->{$attr} = $newval
	}
	return $self->{$attr};

    } elsif ($self->_accessible($attr,'read')) {

	*{$AUTOLOAD} = sub {
	    return $_[0]->{$attr} }; ### end of created subroutine
	return $self->{$attr}  }


    # Must have been a mistake then...
    croak "No such method: $AUTOLOAD";
}


#__________________________________________________________________________________
# Object Methods
#__________________________________________________________________________________

=head1 METHODS

=head2 new

 Title    : new
 Usage    : $MapObj= SeqCanvas->new(
				$axis_length,
				$Frame,
				[$lblSysMess | undef],
				$SeqObj,
				-orientation => ['horizontal'|'vertical']
				[, label => $tag])
				
 Function : create a map from the Feature object provided
 Returns  : Handle to the Map object
 Args     :
	    axis_length in pixels,
	    a Tk::Frame object,
	    a Tk::Label or undef,
	    a BioSeqI compliant object,
	    the orientation for the map,
	    optionally the SeqFeature tag you wish to 
               use as the label

=cut

sub new {
    # returns object reference for success	
    # returns -1 for failed initiation - no $SeqObj supplied
    # returns -2 for wrong object type - must be (ISA) SeqI Sequence object
    # returns -3 sequence  has length 0
    # returns -4 if orientation is uninterpretable
    # returns -5 if supplied frame object is not a TK::frame

    # the reference to TOP in the next line is the top-level TK window.
    # if this is passed as 'defined' then a Tk::Label object with the name
    # lblSysMess ***MUST*** exist in this window to receive output
    # messages from this module.  If $TOP is undefined this feature is disabled.
    my ($caller, $window_length, $frame, $TOP, $SeqObj, %args) = @_;


    my $caller_is_obj = ref($caller);
    my $class = $caller_is_obj || $caller;

    # check incoming data for validity
    if (!$SeqObj){return -1}
    if (!$SeqObj->isa("Bio::SeqI")) {return -2}
    if ($SeqObj->length == 0) {return -3}
    if (!$frame->isa("Tk::Frame")){return -5}

    #Create Object
    my $self = bless {}, $class;

    foreach (keys %args) {
        foreach my $attrname ( $self->_standard_keys ) {
	    if (exists $args{$attrname}) {
		$self->{$attrname} = $args{$attrname} }
	    elsif ($caller_is_obj) {
		$self->{$attrname} = $caller->{$attrname} }
	    else {
		$self->{$attrname} = $self->_default_for($attrname) }
        }
    }

    if ($args{-orientation}) {
	if ($args{-orientation} =~ /h/i) {$self->{-orientation} = "horizontal"}
	elsif ($args{-orientation} =~ /v/i) {$self->{-orientation} = "vertical"}
	else {return -4}
    }

    $self->SysMess($TOP);	# a handle out to the top-level window system for passing messages

    # the sub-frame to hold the zoom-bar
    $self->ZoomFrame($frame->Frame->pack(-side => 'bottom', -fill => 'x'));
    if ($self->{-orientation} eq "horizontal"){
    	$self->SeqFrame($frame->Frame->pack(-side => 'top', expand => 1, -fill => 'x')); # the frame to hold the sequence text
    	$self->ScrollFrame($frame->Frame->pack(-side => 'bottom', -fill => 'x'));
    } else {
    	$self->SeqFrame($frame->Frame->pack(-side => 'left', expand => 1, -fill => 'y')); # the frame to hold the sequence text
    	$self->ScrollFrame($frame->Frame->pack(-side => 'right', -fill => 'y'));
    }
    $self->MapFrame($frame->Frame->pack(-side => 'top')); # the sub-frame to hold the two maps

    # assign some additional values required by the Canvas and AnnotMap
    # ***************** TEMPORARY HACK
    # this should be changed later to make SeqCanvas a real Sequence object
    $self->MapSeq($SeqObj);  
    # *******************************
    # - This line ensures that the sequences fills the allocated space.
    $self->{-range} = [0, ($SeqObj->length)];   	

     if (!($self->width)){$self->width(300)}

    # within these routines the features are counted and assigned
    # colors and offsets from the map axis.  the width of each is
    # thus double (plus strand and minus strand) the largest axis
    # offset of a feature the largest offset value is stored in
    # $self->total_offset
    # ************************************************************
    # ***********************************************************

    # Create the MapCanvases with correct dimensions

    # to make things clearer in the next routine here we figure
    # out which of the two maps is the "wider" and make the
    # default width for both maps equal to this value the "width"
    # of a map depends on how many rows of different features are
    # displayed - i.e. its total offset

    my $map_width = ($self->width);	#/

    if ($self->{-orientation} eq "horizontal") {
       	# the SeqText widget breaks MS-Windows, and is of questionable value anyway...
       	#$self->SeqText($self->SeqFrame->Scrolled("Text", -scrollbars => "s", -height => 3, -background => 'black', -foreground => "white", -wrap => 'none')->pack(-expand => 1, -fill => 'both')); # text box for teh sequence
       	#$self->SeqText->insert('end', "\n");
       	#$self->SeqText->insert('end', $SeqObj->seq);
       	
       	$self->dya(-$map_width/2); # each map is equally distributed
       	$self->fya(-$map_width/2); # each map is equally distributed
       	$self->dyb($map_width/2);  # around the zero axis
       	$self->fyb($map_width/2);  # around the zero axis
       	$self->{-axis_loc} = $map_width/2; # axis goes half-way (this is a strange bug in AnnotMap... even if you specify that the map is -100 to +100, you can't set the axis at 0, you have to set it at +100 to put it in the middle of this 200 range....
       	$self->dxb($window_length); # height is unchanged
        $self->fxb($window_length); # height is unchanged

       	my $DLF = $self->MapFrame->Frame->pack(-side => 'top', -fill => 'both');	# frame for Draft map and labels
       	my $FLF = $self->MapFrame->Frame->pack(-side => 'top', -fill => 'both');	# frame for Finished map and labels
       	
       	$self->DraftLabelCanvas($DLF->Canvas(-width => 100, -height => $map_width, -background => "#ffffff")->pack(-side => 'left', -fill => 'both'));
       	$self->DraftCanvas($DLF->Canvas(-width => $window_length, -height => $map_width, -background => "#ffffff")->pack(-side => 'left', -fill => 'both'));
       	my $Dyscrollbar = $DLF->Scrollbar('-orient' => 'vertical','-command' => sub {$self->DraftLabelCanvas->yview(@_);$self->DraftCanvas->yview(@_)})->pack(-side => 'left', '-fill'=>'y', '-expand' => 'y');
       	
       	$self->FinishedLabelCanvas($FLF->Canvas(-width => 100, -height => $map_width, -background => "#eeeeff")->pack(-side => 'left', -fill => 'both'));
       	$self->FinishedCanvas($FLF->Canvas(-width => $window_length, -height => $map_width, -background => "#eeeeff")->pack(-side => 'left', -fill => 'both'));
       	my $Fyscrollbar = $FLF->Scrollbar('-orient' => 'vertical','-command' => sub {$self->FinishedLabelCanvas->yview(@_);$self->FinishedCanvas->yview(@_)})->pack(-side => 'left', '-fill'=>'y', '-expand' => 'y');
       	
       	$self->DraftLabelCanvas->configure('-yscrollcommand' => ['set' => $Dyscrollbar] );
        $self->FinishedLabelCanvas->configure('-yscrollcommand' => ['set' => $Fyscrollbar] );

        $self->DraftCanvas->configure('-yscrollcommand' => ['set' => $Dyscrollbar] );
        $self->FinishedCanvas->configure('-yscrollcommand' => ['set' => $Fyscrollbar] );
		
		$self->DraftCanvas->configure(-scrollregion => [1, $self->dya, $self->dxb, $self->dyb]);
        $self->FinishedCanvas->configure(-scrollregion => [1, $self->fya, $self->fxb, $self->fyb]);
        $self->DraftLabelCanvas->configure(-scrollregion => [1, $self->dya, 100, $self->dyb]);
        $self->FinishedLabelCanvas->configure(-scrollregion => [1, $self->fya, 100, $self->fyb]);

       	my $s = $self->ScrollFrame->Scrollbar('-orient' => 'horizontal', '-command' => sub {$self->FinishedCanvas->xview(@_); $self->DraftCanvas->xview(@_)});
        	$self->DraftCanvas->configure('-xscrollcommand' => ['set' => $s] ); # since they are identical only one canvas needs to feed-back to the scroll bar to show it's extents
        	$s->pack('-side'=>'bottom', '-fill'=>'x', '-expand' => 'x');
        	$self->ScrollBar($s);

    } else {			# vertical
    	
    	$self->dxa(-$map_width/2); # each map is equally distributed
       	$self->fxa(-$map_width/2); # each map is equally distributed
       	$self->dxb($map_width/2);  # around the zero axis
       	$self->fxb($map_width/2);  # around the zero axis
       	$self->{-axis_loc} = $map_width/2; # axis goes half-way (this is a strange bug in AnnotMap... even if you specify that the map is -100 to +100, you can't set the axis at 0, you have to set it at +100 to put it in the middle of this 200 range....
       	$self->dyb($window_length); # height is unchanged
        $self->fyb($window_length); # height is unchanged
		
		my $DLF = $self->MapFrame->Frame->pack(-side => 'left', -fill => 'both'); # frame for Draft map and labels
    	my $FLF = $self->MapFrame->Frame->pack(-side => 'left', -fill => 'both'); # frame for Finished map and labels
    	
    	$self->DraftLabelCanvas($DLF->Canvas(-width => $map_width, -height => 100, -background => "#ffffff")->pack(-side => 'top', -fill => 'both'));
    	$self->DraftCanvas($DLF->Canvas(-width => $map_width, -height => $window_length, -background => "#ffffff")->pack(-side => 'top', -fill => 'both'));
    	my $Dyscrollbar = $DLF->Scrollbar('-orient' => 'horizontal','-command' => sub {$self->DraftLabelCanvas->xview(@_);$self->DraftCanvas->xview(@_)})->pack(-side => 'top', '-fill'=>'x', '-expand' => 'y');
    	
    	$self->FinishedLabelCanvas($FLF->Canvas(-width => $map_width, -height => 100, -background => "#eeeeff")->pack(-side => 'top', -fill => 'both'));
    	$self->FinishedCanvas($FLF->Canvas(-width => $map_width, -height => $window_length, -background => "#eeeeff")->pack(-side => 'top', -fill => 'both'));
       	my $Fyscrollbar = $FLF->Scrollbar('-orient' => 'horizontal','-command' => sub {$self->FinishedLabelCanvas->xview(@_);$self->FinishedCanvas->xview(@_)})->pack(-side => 'top', '-fill'=>'x', '-expand' => 'y');
       	
       	$self->DraftLabelCanvas->configure('-xscrollcommand' => ['set' => $Dyscrollbar] );
        $self->FinishedLabelCanvas->configure('-xscrollcommand' => ['set' => $Fyscrollbar] );

        $self->DraftCanvas->configure('-xscrollcommand' => ['set' => $Dyscrollbar] );
        $self->FinishedCanvas->configure('-xscrollcommand' => ['set' => $Fyscrollbar] );
		
		$self->DraftCanvas->configure(-scrollregion => [$self->dxa, 1, $self->dxb, $self->dyb]);
        $self->FinishedCanvas->configure(-scrollregion => [$self->fxa, 1, $self->fxb, $self->fyb]);
        $self->DraftLabelCanvas->configure(-scrollregion => [$self->dxa, 1, $self->dxb, $self->dyb]);
        $self->FinishedLabelCanvas->configure(-scrollregion => [$self->dxa, 1, $self->dxb, 100]);

    	my $s = $self->ScrollFrame->Scrollbar('-orient' => 'vertical', '-command' => sub {$self->FinishedCanvas->yview(@_); $self->DraftCanvas->yview(@_)});
        	$self->DraftCanvas->configure('-yscrollcommand' => ['set' => $s] );
        	$s->pack('-side'=>'right', '-fill'=>'y', '-expand' => 'y');
        	$self->ScrollBar($s);
    }		

    $self->DraftCanvas->update;

    $self->DraftCanvas->Tk::bind('<Enter>', sub { $self->DraftCanvas->Tk::focus; } ); # set focus on the appropriate map when mouse enters
    $self->FinishedCanvas->Tk::bind('<Enter>', sub { $self->FinishedCanvas->Tk::focus; } ); # the space

    # and now create the maps
    $self->FinishedMap($self->FinishedCanvas->AnnotMap($self->fxa, $self->fya, $self->fxb, $self->fyb, $self->MapArgs));
    $self->DraftMap($self->DraftCanvas->AnnotMap($self->dxa, $self->dya, $self->dxb, $self->dyb, $self->MapArgs));

    _setupAxes($self);		# draw the axis on the two maps


    # now we have to deal with the elements of the ZOOM
    my $zoomlabel = $self->ZoomFrame->Label(-text => "Zoom")->pack(-side => 'left');

    $self->min_zoom($self->DraftMap->{scale_factor}); # the original maps display the entire sequence, therefore this is the minimum level of zoom
    $self->max_zoom(2);		# this is somewhat arbitrary...
    my $min_scroll = 0;
    my $max_scroll = 100;
    $self->zoom_ratio( ($self->max_zoom - $self->min_zoom)/($max_scroll - $min_scroll)); #/

    my $zoom_scale_length = ($self->{-orientation} eq 'horizontal')?$window_length:$map_width; # the zoom-scale spans the horizontal bottom of the window,
    # the length of which depends on the orientation of the map
    my $zoomscale = $self->ZoomFrame->Scale(-orient => 'horizontal',
					    -sliderlength => 25,
					    -length => $zoom_scale_length - 80,	# the 80 pixels compensates for the "Zoom" label beside the widget
					    -width => 10,
					    -from => 0,
					    -to => 100,
					    -showvalue => 0,
					    -variable => \$self->{zoom_level},
					    -command => sub {$self->DoZoom()} );
    $zoomscale->pack(-side => 'left', -expand => 'yes', -fill => 'x', -anchor => 'e');    	
    $self->ZoomBar($zoomscale);

    foreach my $source(@{$self->InitialSources}){
    	$self->_check_and_expand_draft_canvas($source);
    	$self->addSource($source);
    }
	foreach my $label(@{$self->InitialFinishedLabels}){
    	$self->_check_and_expand_finished_canvas($label);
    	$self->addFinishedSourceLabel($label);
    }
    foreach my $source($self->Sources){
    	$self->_drawDraftLabels([$source]);
    }
    foreach my $label($self->FinishedSourceLabels){
    	$self->_drawFinishedLabels([$label]);
    }

    # now that everything is setup, go ahead and draw the features
    my @features = $self->MapSeq->top_SeqFeatures;
    my @IDs = $self->mapFeatures("both", \@features); # only the features from a top_SeqFeatures call -> screened for GeneStructure objects in this routine

    $self->_bindMultiSelection();

    my $toplevel = $self->DraftCanvas->toplevel;
    my $a = $toplevel->geometry;
	$a =~ /(\d+)x(\d+)\+-?(\d+)\+-?(\d+)/;      #get current screen position of top-level window eg. 500x300+20+-45
	$toplevel->geometry("$1"."x"."$2+10+10");  # set it so that the control bar is entirely visible at the top of the screen

    #return ($self, \@IDs);		# return the handle
    return $self;
}

sub _bindMultiSelection {

    my ($self) = @_;
    # the line below converts the x/y coordinates of the event into the canvas coordinates
    $self->DraftCanvas->Tk::bind("<ButtonPress-1>" => 
				 [ sub { shift;
					 $self->dragx1($self->DraftCanvas->canvasx(shift)); 
					 $self->dragy1($self->DraftCanvas->canvasy(shift))}, 
				   Ev('x'), Ev('y')]);   
    $self->DraftCanvas->Tk::bind("<B1-Motion>" => 
				 [sub {	shift; 
					my $tx2 = shift; my $ty2 = shift;
                                        # the x1/y1 are stored during the button-press event above
					my ($x1, $y1) = ($self->dragx1, $self->dragy1);	
                                        # convert the global x/y coordinate to the canvas x/y coords
					
					my $x2 = $self->DraftCanvas->canvasx($tx2);
					my $y2 = $self->DraftCanvas->canvasy($ty2);
                                        # delete existing boxse
					return if (!($x1 && $x2 && $y1 && $y2));
					$self->DraftCanvas->delete("withtag", "multi_box");
					$self->FinishedCanvas->delete("withtag", "multi_box"); #  "
                                        # create a new one
					$self->DraftCanvas->createRectangle($x1, $y1, $x2, $y2, 
									    -tags => "multi_box"); 
				    },
                                  # as parameters send the global x/y coordinates of the event
				  Ev('x'), Ev('y')] 
				 );

    $self->DraftCanvas->Tk::bind("<ButtonRelease-1>" => 
				 [sub {	shift; 
					$self->dragx2($self->DraftCanvas->canvasx(shift)); 
					$self->dragy2($self->DraftCanvas->canvasy(shift));
					my ($x1, $x2, $y1, $y2) = ($self->dragx1, 
								   $self->dragx2, 
								   $self->dragy1, $self->dragy2);
					return if (!($x1 && $x2 && $y1 && $y2));
					if ($x1 > $x2){($x1, $x2) = ($x2, $x1)}
					if ($y1 > $y2){($y1, $y2) = ($y2, $y1)}
					if (($x2-$x1 < 10 )||($y2 - $y1 < 10)) { # set sensitivity
                                            # delete existing boxes
					    $self->DraftCanvas->delete("withtag", "multi_box");	
					    $self->FinishedCanvas->delete("withtag", "multi_box"); #  "
					    return;
					}
					$self->clearSelections;
					$self->DraftCanvas->delete("withtag", "multi_box");
					$self->FinishedCanvas->delete("withtag", "multi_box");
					$self->DraftCanvas->addtag("group_select", "overlapping", 
								   $x1, $y1, $x2, $y2);
					$self->selectWithTag(["group_select"], 'draft');
					$self->DraftCanvas->dtag("all", "group_select");	
				    },
				  Ev('x'), Ev('y')]
				 );

    $self->FinishedCanvas->Tk::bind("<ButtonPress-1>" => 
				    [sub { shift;
					   $self->dragx1($self->DraftCanvas->canvasx(shift)); 
					   $self->dragy1($self->DraftCanvas->canvasy(shift))},
				     Ev('x'), Ev('y')]);

    $self->FinishedCanvas->Tk::bind("<B1-Motion>" => 
				    [sub { shift; 
					   my $tx2 = shift; my $ty2 = shift;
					   my ($x1, $y1) = ($self->dragx1, $self->dragy1);
					   my $x2 = $self->FinishedCanvas->canvasx($tx2);
					   my $y2 = $self->FinishedCanvas->canvasy($ty2);
					   return if (!($x1 && $x2 && $y1 && $y2));
						$self->DraftCanvas->delete("withtag", "multi_box");
					   $self->FinishedCanvas->delete("withtag", "multi_box");
					   $self->FinishedCanvas->createRectangle($x1, $y1,$x2, 
										  $y2, -tags => "multi_box");
				       },
				     Ev('x'), Ev('y')]
				    );

    $self->FinishedCanvas->Tk::bind("<ButtonRelease-1>" => 
				    [sub {shift; 
					  $self->dragx2($self->FinishedCanvas->canvasx(shift)), 
					  $self->dragy2($self->FinishedCanvas->canvasy(shift));
					  my ($x1, $x2, $y1, $y2) = ($self->dragx1, 
								     $self->dragx2, $self->dragy1, 
								     $self->dragy2);
					  return if (!($x1 && $x2 && $y1 && $y2));
						if ($x1 > $x2){($x1, $x2) = ($x2, $x1)}
					  if ($y1 > $y2){($y1, $y2) = ($y2, $y1)}
					  if (($x2-$x1 < 10 )||($y2 - $y1 < 10)) { # set sensitivity
                                              # delete existing boxes
					      $self->DraftCanvas->delete("withtag", "multi_box"); 
					      $self->FinishedCanvas->delete("withtag", "multi_box"); #  "
					      return;
					  }
					  $self->clearSelections;
					  $self->DraftCanvas->delete("withtag", "multi_box");
					  $self->FinishedCanvas->delete("withtag", "multi_box");
					  $self->FinishedCanvas->addtag("group_select", 
									"overlapping", $x1, $y1, 
									$x2, $y2);
					  $self->selectWithTag(["group_select"], 'finished');
					  $self->FinishedCanvas->dtag("all", "group_select");	
				      },
				     Ev('x'), Ev('y')]
				    );
}


sub _setupAxes {
    my ($self)=@_;
    my $draftmap = $self->DraftMap;            # set references to keep code clearer
    my $finishedmap = $self->FinishedMap;
    my $draftc = $self->DraftCanvas;
    my $finishedc = $self->FinishedCanvas;
    my $seqlength = $self->MapSeq->length;

    # Set up axis
    $draftmap->   MapAxis('-color' => 'black', '-ticks' => 5000, '-scale' => 1000,
			  -tags => 'axis1', -axis_start => 0);
    $finishedmap->MapAxis('-color' => 'black', '-ticks' => 5000, '-scale' => 1000,
			  -tags => 'axis1', -axis_start => 0);

#    else {
#    	$draftmap->   MapAxis('-color' => 'black', '-ticks' => 1000, '-scale' => 1000,
#			      -axis_start => 0);
#    	$finishedmap->MapAxis('-color' => 'black', '-ticks' => 1000, '-scale' => 1000,
#			      -axis_start => 0);

### AXIS 2
    $draftmap->   MapAxis('-ticks' => 2500, '-scale'=> 1000, '-offset' => 9999,
			  '-tags' => 'axis2', -axis_start => 0);
    $finishedmap->MapAxis('-ticks' => 2500, '-scale'=> 1000, '-offset' => 9999,
			  '-tags' => 'axis2', -axis_start => 0);
### AXIS 3
    $draftmap->   MapAxis('-ticks' => 1000, '-scale'=> 1000, '-offset' => 9999,
			  '-tags' => 'axis3', -axis_start => 0);
    $finishedmap->MapAxis('-ticks' => 1000, '-scale'=> 1000, '-offset' => 9999,
			  '-tags' => 'axis3', -axis_start => 0);
### AXIS 4
    $draftmap->   MapAxis('-ticks' => 100, '-scale'=> 1, '-offset' => 9999,
			  '-tags' => 'axis4', -axis_start => 0);
    $finishedmap->MapAxis('-ticks' => 100, '-scale'=> 1, '-offset' => 9999,
			  '-tags' => 'axis4', -axis_start => 0);


    # zoom-triggering is an idea from Nomi Harris in her Genotator program
    # we changed the structure of the zoom triggers to make them "perlish"
    # by putting them in a hash, but the fundamental concept is Nomi's.  The idea is that
    # several axes are drawn on the canvas with different frequencies of ticks,
    # but most are drawn outside of the visible canvas area.
    # During the zoom in/out events these "hidden" axes are shifted
    # into and out of the visible area (by a canvas->move call)
    # note that these axes are **independent objects** relative to the Bio::Tk_Map Axis object.
    # i.e. you are not changing the Bio::Tk map axis when you call "move"  you are
    # simply shifting the position of a line-with-ticks-and-labels object
    # that has been given the tag "axis2" or whatever...

    my %zoom_triggers = (hin=>{	0.015	=> sub {$draftc   ->move('axis1', 0,-9999);
						$finishedc->move('axis1', 0,-9999);
						$draftc   ->move('axis2', 0, 9999);
						$finishedc->move('axis2', 0, 9999);
					    },

				0.07	=> sub {$draftc   ->move('axis3', 0, 9999);
						$finishedc->move('axis3', 0, 9999);
					    },

				0.5	=> sub {$draftc   ->move('axis4', 0, 9999);
						$draftc   ->move('axis3', 0,-9999);
						$draftc   ->move('axis2', 0,-9999);
						$finishedc->move('axis4', 0, 9999);
						$finishedc->move('axis3', 0,-9999);
						$finishedc->move('axis2', 0,-9999);
					    }},

			 hout=>{ 0.015	=> sub {$draftc   ->move('axis1', 0, 9999);
						$finishedc->move('axis1', 0, 9999);
				                $draftc   ->move('axis2', 0,-9999);
						$finishedc->move('axis2', 0,-9999);
					    },

				 0.07	=> sub {$draftc   ->move('axis3', 0,-9999);
						$finishedc->move('axis3', 0,-9999);
					    },

				 0.5  	=> sub {$draftc   ->move('axis4', 0,-9999);
						$draftc   ->move('axis3', 0, 9999);
						$draftc   ->move('axis2', 0, 9999);
						$finishedc->move('axis4', 0,-9999);
						$finishedc->move('axis3', 0, 9999);
						$finishedc->move('axis2', 0, 9999);
					    }},

			 vin=>{	0.015	=> sub {$draftc   ->move('axis1', -9999,0);
						$finishedc->move('axis1', -9999,0);
						$draftc   ->move('axis2',  9999,0);
						$finishedc->move('axis2',  9999,0);
					    },

				0.07	=> sub {$draftc   ->move('axis3',  9999,0);
						$finishedc->move('axis3',  9999,0);
					    },

				0.5	=> sub {$draftc   ->move('axis4',  9999,0);
						$draftc   ->move('axis3', -9999,0);
						$draftc   ->move('axis2', -9999,0);
						$finishedc->move('axis4',  9999,0);
						$finishedc->move('axis3', -9999,0);
						$finishedc->move('axis2', -9999,0);
					    }},

			 vout=>{0.015	=> sub {$draftc   ->move('axis1',  9999,0);
						$finishedc->move('axis1',  9999,0);
						$draftc   ->move('axis2', -9999,0);
						$finishedc->move('axis2', -9999,0);
					    },

				0.07	=> sub {$draftc   ->move('axis3', -9999,0);
						$finishedc->move('axis3', -9999,0);
					    },

				0.5  	=> sub {$draftc   ->move('axis4', -9999,0);
						$draftc   ->move('axis3',  9999,0);
						$draftc   ->move('axis2',  9999,0);
						$finishedc->move('axis4', -9999,0);
						$finishedc->move('axis3',  9999,0);
						$finishedc->move('axis2',  9999,0);
					    }}
			);

    $self->zoom_triggers(\%zoom_triggers);

}

sub DoZoom  {	
    # this is also based conceptually on Nomi Harris' Genotator code
    #  DoZoom provides an extra layer of abstraction above the actual
    #  zooming, to allow for scale-triggered features.
    # we modified the code somewhat, but you will still be able
    # to recognize the basic structure of the DoZoom event
    # as coded in Genotator.

    my ($self)=@_;
    my ($desired_scale,$zoom_ratio,$min_zoom,$max_zoom, $triggers) = ($self->zoom_level,$self->zoom_ratio, $self->min_zoom, $self->max_zoom, $self->zoom_triggers);
    
    my $draftmap = $self->DraftMap;           # set up easy references
    my $finishedmap = $self->FinishedMap;
    my $draftc = $self->DraftCanvas;
    my $finishedc = $self->FinishedCanvas;
    my ($annotmap);
    if ($self->AnnotTextMap){$annotmap = $self->AnnotTextMap}
    my ($pre_scale_factor, $post_scale_factor,
       $trigger_point, $coderef, $trigger_struct);

    my $current_loc = $self->current_loc;     # the location of the last clicked widget

    $draftc->delete('selection_box');           # since boxes don't zoom they have to be deleted
    $draftc->dtag('selected');                  # along with corresponding "selected" tags
    $finishedc->delete('selection_box');
    $finishedc->dtag('selected');

    $pre_scale_factor = $draftmap->{scale_factor};   # should be the same for both maps... if not, then the whole shebang is buggered!

    my $normalized_desired_scale = (($desired_scale/100)**2)*100*$zoom_ratio + $min_zoom;

    my $zoom_factor = $normalized_desired_scale/$pre_scale_factor;

    # HERE IS WHERE THE AnnotMap::Zoom SUBROUTINE IS CALLED
    # ******************************************************
    $draftmap->Zoom($zoom_factor, $current_loc);
    $finishedmap->Zoom($zoom_factor, $current_loc);
    if ($annotmap) {$annotmap->Zoom($zoom_factor, $current_loc)};
    # *****************************************************

    my %triggs = %{$triggers};
    $post_scale_factor = $draftmap->{scale_factor};

    if ($zoom_factor > 1) {	# Zoom in	
    	if ($self->{-orientation} eq "horizontal"){
	    foreach my $scale_threshold (keys %{$triggs{hin}}) {
		if ($pre_scale_factor  <  $scale_threshold &&
		    $post_scale_factor >= $scale_threshold) {
		    &{$triggs{hin}{$scale_threshold}};
		}
	    }
    	} else {
	    foreach my $scale_threshold (keys %{$triggs{vin}}) {
		if ($pre_scale_factor  <  $scale_threshold &&
		    $post_scale_factor >= $scale_threshold) {
		    &{$triggs{vin}{$scale_threshold}};
		}
	    }
    	}
    }

    elsif ($zoom_factor < 1)  {    # Zoom out	
    	if ($self->{-orientation} eq "horizontal"){
         	foreach my $scale_threshold (keys %{$triggs{hout}}) {
         	    if ($post_scale_factor <  $scale_threshold &&
         	        $pre_scale_factor  >= $scale_threshold) {
         		&{$triggs{hout}{$scale_threshold}};
       	    	}
    		}
    	} else {
         	foreach my $scale_threshold (keys %{$triggs{vout}}) {
         	    if ($post_scale_factor <  $scale_threshold &&
         	        $pre_scale_factor  >= $scale_threshold) {
         		&{$triggs{vout}{$scale_threshold}};
       	    	}
    	    }
    	}
    }
}


sub _processSeqFeatures {
    # all features should be top_SeqFeatures when they enter this routine...
    my ($self, $features) = @_;
    my @features = @{$features};
	foreach my $feature(@features){
		$self->_extract_sources([$feature]);  # this gets the feature and all sub-features, updates labels and canvas sizes
	}
	foreach my $feature(@features){
		$self->_extract_transcripts([$feature]);  # this updates both labels and canvas sizes
	}

}


sub _check_and_expand_draft_canvas {

	my ($self,$source) = @_;
	
	foreach my $current_source($self->Sources){
		return if ($current_source eq $source);  # if the given source exists, then exit this routine ASAP
	}
	# at this point we have determined that the $source is a new one.
	
	my $offset = $self->next_draft_offset;
	my $ColorPos = $self->next_colorpos;
	my @colorlist = $self->colorlist;
	my %colordef = $self->colordef;
	
	$self->current_colors->{$source} = $colordef{$colorlist[$ColorPos]};
	$self->current_offsets->{$source} = $self->whitespace + ($offset * $self->def_offset);
		if ($self->{-orientation} eq "horizontal"){
			my $yb = $self->current_offsets->{$source};
			my $ya = -$yb;
			if ($yb > $self->dyb){
				$self->dya($ya);
				$self->dyb($yb);
			}
			$self->_drawDraftLabels([$source]);
			$self->DraftCanvas->update;
		} else {
			my $xb = $self->current_offsets->{$source};
			my $xa = -$xb;
			if ($xb > $self->dxb){
				$self->dxa($xa);
				$self->dxb($xb);
			}
			$self->_drawDraftLabels([$source]);
			$self->DraftCanvas->update;
		}
}

sub _check_and_expand_finished_canvas {

	my ($self, $label) = @_;

	foreach my $current_label($self->FinishedSourceLabels){
		return if ($current_label eq $label);  # if the given source exists, then exit this routine ASAP
	}
	# at this point we have determined that the $source is a new one.
	
	my $offset = $self->next_finished_offset;
	
	my @colorlist = $self->colorlist;
	my %colordef = $self->colordef;
	my $this_offset = $self->whitespace + ($offset * $self->def_offset);
	
	$self->current_colors->{$label} = $colordef{$colorlist[0]};  # was $colorpos instead of 0... but I want them to be consistent
	$self->current_offsets->{$label} = $this_offset;
	
		if ($self->{-orientation} eq "horizontal"){
			my $yb = $this_offset;
			my $ya = -$yb;
			if ($yb > $self->fyb){
				$self->fya($ya);
				$self->fyb($yb); # write the new dimensions of self to self
			}	
			$self->_drawFinishedLabels([$label]);
			$self->FinishedCanvas->update;
		} else {
			my $xb = $this_offset;
			my $xa = -$xb;
			if ($xb > $self->fxb){
				$self->fxa($xa);
				$self->fxb($xb); # write the new dimensions of self to self			
			}
			$self->_drawFinishedLabels([$label]);
			$self->FinishedCanvas->update;
		}
	return $this_offset; 	
}

sub _extract_sources {   # sources are used to define both offset and color on the draft canvas, but only color on the finished canvas
    my ($self, $features) = @_;
    my @features = @{$features};
    my %sources;    # use a hash do simplify screening for duplicate entries - assignment of 'undef' to the same hash key can be safely made multiple times
    my @currentSources = $self->Sources;
    foreach my $source(@currentSources){
    	$sources{$source}=1;
    }
    my $flag;

    foreach my $feature(@features) {
		if (!(($feature->primary_tag eq "gene")||($feature->can("transcripts")))){ # this filters out top-level gene objects
			my $this_source = $feature->source_tag;  # get the source tag
			if (!$this_source) {$this_source = "undefined"}  # or assign it if it doesn't exist
			if (!$sources{$this_source}){$self->_check_and_expand_draft_canvas($this_source);}  # if it is unknown, then expand the canvas
			$sources{$this_source}=1;     # this is essentially a non-redundant list of sources        # now set it to "known"
		}
		my @subfeatures = $self->_getAllSubFeatures($feature);   # get all sub-features
		foreach my $subfeature(@subfeatures){
			next if (($subfeature->primary_tag eq "gene")||($subfeature->can("transcripts"))||($subfeature->can("exons"))); # this filters out top-level gene objects and transcript objects
			my $this_source = $subfeature->source_tag; # do the same as above
			if (!$this_source) {$this_source = "undefined"}
			if (!$sources{$this_source}){$self->_check_and_expand_draft_canvas($this_source);}
			$sources{$this_source}=1;
		}			
    }
    my @sources = (keys %sources);  # get the non-redundant list
    $self->Sources(@sources);      # and make the list of sources
    return @sources;
}


sub _getAllSubFeatures {
	my ($self, $feature) = @_;
	my @all_features;
	push @all_features, $feature;
	if ($feature->sub_SeqFeature){
		foreach my $sub($feature->sub_SeqFeature){
			push @all_features, $self->_getAllSubFeatures($sub);
		}
	}	
	return @all_features;
}


sub _extract_transcripts {
    my ($self, $features) = @_;
    my @features = @{$features};
	my %Labels;
    my @currentLabels = $self->FinishedSourceLabels;  # at the beginning this should be a list of 1 element - "gene"
    foreach my $label(@currentLabels){
    	$Labels{$label}=1;        # set these labels as being "known" to us.
    }

    foreach my $feature(@features) {
	    my $model=0;   # this is a counter for the number of transcript models contained in the gene

		next if (!($feature->can("transcripts")) && !($feature->can("exons")) && ($feature->primary_tag ne "gene"));  # we only want GeneStructureI compliant objects on finished map, but allow things with primary tag "gene" to be mapped also just to be compliant with SeqIO parsing of genbank files (ugly!!)
	    $feature->{SeqCanvas_offset} = $self->current_offsets->{"gene"};  # assign a gene offset to this feature
		if ($feature->can("transcripts")){                         # and get out now if it isn't GeneStructureI compliant
    		my @transcripts = $feature->transcripts;     # get all transcripts from this object
    		next if ($#transcripts == -1);               # exit if there are none
    		foreach my $transcript(@transcripts){        # for every transcript give it a new offset & assign it directly to the transcript object
    			++$model;
    			my $offset;                                # increment model counter -> increment offset from the axis.
    			if (!($Labels{"transcript$model"})){$offset = $self->_check_and_expand_finished_canvas("transcript$model")}  # if label is unknown add it to the finished label canvas, update both label canvas and map size
    			else {$offset = $self->current_offsets->{"transcript$model"}}
    			$transcript->{SeqCanvas_offset} = $offset;
    			$Labels{"transcript$model"} = 1;  # define this label as known
    		}
		} elsif ($feature->can("exons")){
		
		} else {next}
	}
	my @transcripts = (keys %Labels);
	$self->FinishedSourceLabels(@transcripts);
	return @transcripts;

}

sub _drawFinishedLabels {

    my ($self, $sources) = @_;
    my $canvas = $self->FinishedLabelCanvas;
    my $map = $self->FinishedCanvas;
    ###########################################################################
    #  now draw the labels on the label canvas - one for each line of features
    #############################################################################

    my $text_width = ($self->{-orientation} eq "horizontal") ? 0:1;
    # for horizontal it is 20 characters long, for vertical it is 1 character
    # wide (essentially vertically written)
    # now draw the labels
    my @sources = @{$sources};

    foreach my $source(@sources) {
    	my $color = $self->current_colors->{$source};
    	my $offset = $self->current_offsets->{$source};
    	if ($self->{-orientation} eq "vertical") {
    		# vertical text requires splitting between every character,
    	    # and splits, on a canvas, can only occur where there is a space
    	    $source = join ' ', (split //, $source);
    	    # so we break the string up with spaces between each character.
    	}

    	if ($self->{-orientation} eq "horizontal") {
    	    $canvas->createText(5, $offset-5,
    				# the -5 is because the AnnotMap function draws
    				# the bars using a different centering mechanism
    				# relative to simply writing text on the canvas
    				-text => $source,
    				-fill => $color,
    				-width => $text_width,
    				#-justify => 'right',
    				-font => "Courier 10 normal",
    				-anchor => 'nw',
    				);
    	    $canvas->createText(5, -$offset-5,
    				# the -5 is because the AnnotMap function draws
    				# the bars using a different centering mechanism
    				# relative to simply writing text on the canvas
    				-text => $source,
    				-fill => $color,
    				-width => $text_width,
    				#-justify => 'right',
    				-font => "Courier 10 normal",
    				-anchor => 'nw',

    				);
    	} else {
    	    $canvas->createText($offset-5, 5,
    				# the +5 is because the AnnotMap function draws
    				# the bars using a different centering mechanism
    				# relative to simply writing text on the canvas
    				-text => $source,
    				-fill => $color,
    				-width => $text_width,
    				#-justify => 'right',
    				-anchor => 'nw',
    				);
    	    $canvas->createText(-$offset-5, 5,
    				# the +5 is because the AnnotMap function draws
    				# the bars using a different centering mechanism
    				# relative to simply writing text on the canvas
    				-text => $source,
    				-fill => $color,
    				-width => $text_width,
    				#-justify => 'right',
    				-anchor => 'nw',
    				);

    	}	
    }

	if ($self->{-orientation} eq "horizontal"){
		$canvas->configure(-scrollregion => [1, $self->fya-10, 100,        $self->fyb+10]);
    	$map->configure(-scrollregion =>    [1, $self->fya-10, $self->fxa, $self->fyb+10]);
		$self->FinishedMap->{canvas_min} = $self->fya-10; # inform AnnotMap about the new size for zooming purposes
		$self->FinishedMap->{canvas_max} = $self->fyb+10; # the +/- 10 is because I set the canvas scroll region for the labels to be +/- 10 compared to the actual offset

	} else {
		$canvas->configure(-scrollregion => [$self->fxa-10, 1, $self->fxb+10, 100]);
    	$map->configure(-scrollregion =>    [$self->fxa-10, 1, $self->fxb+10, $self->fyb]);
		$self->FinishedMap->{canvas_min} = $self->fxa-10; # inform AnnotMap about the new size for zooming purposes
		$self->FinishedMap->{canvas_max} = $self->fxb+10;
	}
}

sub _drawDraftLabels {	
    my ($self, $sources) = @_;
    my $canvas = $self->DraftLabelCanvas;
    my $map = $self->DraftCanvas;
    ###########################################################################
    #  now draw the labels on the label canvas - one for each line of features
    #############################################################################
    my $text_width = ($self->{-orientation} eq "horizontal") ? 0:1; 
    # for horizontal it is 20 characters long, for vertical it is 1 character 
    # wide (essentially vertically written)
    # now draw the labels
    my @sources = @{$sources};

    foreach my $source(@sources) {
    	my $color = $self->current_colors->{$source};
    	my $offset = $self->current_offsets->{$source};
    	if ($self->{-orientation} eq "vertical") {
                # vertical text requires splitting between every character,
    	    # and splits only occurr before spaces
    	    $source = join ' ', (split //, $source);
                # so we break the string up with spaces between each character.
    	}

    	if ($self->{-orientation} eq "horizontal") {
    	    $canvas->createText(5, $offset-5,
    				# the -5 is because the AnnotMap function draws
    				# the bars using a different centering mechanism
    				# relative to simply writing text on the canvas
    				-text => $source,
    				-fill => $color,
    				-width => $text_width,
    				#-justify => 'right',
    				-font => "Courier 10 normal",
    				-anchor => 'nw',
    				);
    	    $canvas->createText(5, -$offset-5,
    				# the -5 is because the AnnotMap function draws
    				# the bars using a different centering mechanism
    				# relative to simply writing text on the canvas
    				-text => $source,
    				-fill => $color,
    				-width => $text_width,
    				#-justify => 'right',
    				-font => "Courier 10 normal",
    				-anchor => 'nw',

    				);
    	} else {
    	    $canvas->createText($offset-5, 5,
    				# the +5 is because the AnnotMap function draws
    				# the bars using a different centering mechanism
    				# relative to simply writing text on the canvas
    				-text => $source,
    				-fill => $color,
    				-width => $text_width,
    				#-justify => 'right',
    				-anchor => 'nw',
    				);
    	    $canvas->createText(-$offset-5, 5,
    				# the +5 is because the AnnotMap function draws
    				# the bars using a different centering mechanism
    				# relative to simply writing text on the canvas
    				-text => $source,
    				-fill => $color,
    				-width => $text_width,
    				#-justify => 'right',
    				-anchor => 'nw',
    				);

    	}	
    }
	if ($self->{-orientation} eq "horizontal"){
		$canvas->configure(-scrollregion => [1, $self->dya-10, 100,        $self->dyb+10]);
    	$map->configure(-scrollregion =>    [1, $self->dya-10, $self->dxa, $self->dyb+10]);
		$self->DraftMap->{canvas_min} = $self->dya-10; # inform AnnotMap about the new size for zooming purposes
		$self->DraftMap->{canvas_max} = $self->dyb+10;				
	} else {
		$canvas->configure(-scrollregion => [$self->dxa-10, 1, $self->dxb+10, 100]);
    	$map->configure(-scrollregion =>    [$self->dxa-10, 1, $self->dxb+10, $self->dyb]);
		$self->DraftMap->{canvas_min} = $self->dxa-10; # inform AnnotMap about the new size for zooming purposes
		$self->DraftMap->{canvas_max} = $self->dxb+10; # the +/- 10 is because I set the canvas scroll region for the labels to be +/- 10 compared to the actual offset
	}
}

sub _selectFeature { 

    # the upshot of this is to identify and box any widgets which are
    # "current" on a particular canvas. A widget with the tag
    # "now_current" comes from another subroutine which has
    # computationally selected this item for whatever reason.  The tag
    # "current" comes from the Tk canvas itself, and is added to a
    # widget when it is clicked by the mouse.  We deal with both of
    # these situations here.  SorM holds 'single' or 'multi', and is
    # simply needed to tell the drawSelectionBox routine whether or
    # not to delete any existing selection boxes At the end of this
    # routine, any "current" and "now_current" widget is given the
    # "selected" tag.

    my ($self, $canvas, $map, $SorM) = @_;
    my @exons = $canvas->find('withtag', 'now_current'); 
    # if the widget was selected by a subroutine then it has the
    # "now_current" tag

    if (!@exons){@exons = $canvas->find('withtag', 'current')} 
    # if it was selected by the mouse it has the "current" tag
    # only one of these two options will be true under normal circumstances
    my $widgetid = shift @exons; 
    # this is presumed to be a list of only one element - the current widget id

    my @tags = $canvas->gettags('current'); # get the other tags for the currently selected widget
    push @tags, ($canvas->gettags('now_current')); 
    # one or the other of these will return undef under normal circumstances

    my ($FeatureID, $strand, $source, $start, $stop, $offset) = _extractTags(\@tags);
    # parse the tags to get the juicy bits
    my $exitflag = "false";
    foreach my $tag (@tags){
    	if ($tag eq "selected"){ # this object has already been selected! so... unselect it
	    $canvas->delete("sel_box_$FeatureID"); # delete the selection box from around this object only
	    $canvas->dtag($FeatureID, "selected"); # remove the "selected" status of this widget
	    $canvas->dtag('now_current');
	    $exitflag = "true";	# raise the flag to exit this routine
    	}
    }
    return if ($exitflag eq "true"); # get out if the event was a de-selection event

    my ($FeatureIndex)  = ($FeatureID =~ /^FID(.+)/); 
    # get the IndexedFeatureList index pointer for this feature
    
    if ( ! defined $FeatureIndex ) {   # there are all sorts of other invisible junks on the map,
	$canvas->dtag('now_current');      # so filter out these things and ignore them if they are clicked on
	return; 
    } 


    
    #my $feature = $self->{IndexedFeatureList}->[$FeatureIndex];
    # then extract this Bio::Feature object from the list
    # $feature now contains the actual BioSeqFeature object,
    # so we can use the Feature methods...
    # like start, stop, strand, etc.
    #my $start = $feature->start;
    #my $stop = $feature->end;

    #my $offset;
    #if ($feature->has_tag("SeqCanvas_offset")){
    #	($offset) = $feature->each_tag_value("SeqCanvas_offset");
    #} else {    	
    #	$offset = $self->current_offsets->{$source};
    #}

    # offset from axis always depends on the source tag
    # quickly nab the position that was clicked so that we can zoom around this
    my $current_loc = ($self->{-orientation} eq "horizontal") ? 
	($canvas->canvasx($canvas->XEvent->x)) : ($canvas->canvasy($canvas->XEvent->y));  #/)
    $self->current_loc($current_loc);				
    # this becomes the location on the map around which we will zoom if the user choses
    
    if ($strand eq "-1") {
	_drawSelectionBox ($self, $canvas, $map, $start, $stop, $offset, $FeatureID, $SorM);
    } else {
	_drawSelectionBox ($self, $canvas, $map, $start, $stop, -$offset, $FeatureID, $SorM);
    }
    $canvas->addtag("selected", "withtag", "$FeatureID");
    
    #original
    $canvas->dtag('now_current');

    my ($index1, $index2);
    if ($self->{-orientation} eq "horizontal"){  # only horizontal maps display sequence info
    	$index1 = "2." . ($start-1);                 # convert seq coordinates into text-coordinates
    	$index2 = "2." . ($stop);
    }
    my $color = $self->current_colors->{$source};

    # removed to accomodate MS Windows OS's
    #if ($self->{-orientation} eq "horizontal"){
    #	if ($SorM eq "single"){$self->SeqText->tagDelete("currently_selected", "currently_selected")}   # remove existing tags
    #	$self->SeqText->tagAdd("currently_selected", $index1, $index2); # add the tag to the new region
    #	$self->SeqText->tagConfigure("currently_selected", -foreground => $color);  # recolor it to the correct color
    #	$self->SeqText->see($index1);  # bring it into view
    #}
    	
}

sub _drawSelectionBox {		# this is conceptually based on Nomi Harris' Genotator code
    my($self, $canvas, $map, $start, $stop, $offset, $FeatureID, $SorM) = @_;
    #print "start $start  end $stop  offset $offset SM $SorM\n";

    # ******* THIS MUST BE CHANGED ********
    my $y1 = $offset -3; #/
    my $y2 = $y1 + 6;

    if ((defined $SorM) && ($SorM eq "single")) {clearSelections($self)}; 
    # if, for example, the user is not holding now the "shift" key when they click
    # then clear all other selections/boxes

    my @tags = ('selection_box', "sel_box_$FeatureID");
    if ($self->{-orientation} eq "vertical"){
	$canvas->create('rectangle', # draw a rectangle around the colored feature box widget
			$y1, $map->MapLocation($start),
			$y2, $map->MapLocation($stop),
			'-tags' => \@tags, # add a tag so that we can delete it later if necessary
			);
    } else {
	$canvas->create('rectangle', # draw a rectangle around the colored feature box widget
			$map->MapLocation($start), $y1,
			$map->MapLocation($stop), $y2,
			'-tags' => \@tags, # add a tag so that we can delete it later if necessary
			);
    }
}


sub _extractTags {
    my (@tagsref) = @_;
    my $tags = shift @tagsref;
    my ($FeatureID, $strand, $source, $start, $stop, $offset);
    foreach my $tag(@{$tags}){
	if ($tag =~ /^(FID.+)/) {$FeatureID = $1}
	if ($tag =~ /^Source (.+)/){$source = $1}
	if ($tag =~ /^Strand (.+)/){$strand = $1}
    if ($tag =~ /^_SC_start (.+)/){$start = $1}
    if ($tag =~ /^_SC_stop (.+)/){$stop = $1}
    if ($tag =~ /^_SC_offset (.+)/){$offset = $1}

    }
    return ($FeatureID, $strand, $source, $start, $stop, $offset);
}

sub _isLabel {
    my ($self, $widgetTkID) = @_;
    my @tags = $self->DraftCanvas->gettags($widgetTkID);
    push @tags, $self->FinishedCanvas->gettags($widgetTkID);
    foreach my $tag(@tags){
	if ($tag eq "bioTk_Map_Label"){return 1}
    }
    return 0;
}


# *********************************************
# *******************  API STARTS HERE ********
# *********************************************

=pod

=head2 mapFeatures

 Title    : mapFeatures
 Usage    : $FeatureIDs = $MapObj->mapFeatures('draft'|'finished'|undef,
					       \@FeatureObj)
 Function : map SeqFeature objects.  Objects which are GeneStructureI compliant
            will be broken down and their individual features mapped onto
            the draft map according to their source_tag, and on the finished
            map according to which Transcript(s) they participate in.
            N.B. 'draft' versus 'finished' is now ignored but is retained
            in the call for backwards compatibility with SeqCanvas v1.0.
 Returns  : reference to a list of the FeatureID's of the mapped Features
 Args     : 'draft'|'finished'|undef, \@FeatureObj

=cut


sub mapFeatures {
    my ($self, $whichmap, $features) = @_;
    my ($map, $canvas, @IDs);
   	$self->_processSeqFeatures($features);
   	
   	# need to map the draft features first in order to assign the colors to the source-tags
   	foreach my $feature(@{$features}){
   		my @sub_features = $self->_getAllSubFeatures($feature);
   		push @IDs, ($self->_mapOntoDraft(\@sub_features));
    }
   	
   	# now map any gene-objects and their transcripts
   	push @IDs, ($self->_mapOntoFinished($features));

    return @IDs;
}


sub _mapOntoDraft {

	my ($self, $features)=@_;
    my @MappedIDs;


    foreach my $feature(@{$features}) {
    	next if ($feature->primary_tag eq "source"); 	# this just gives one BIIIG line representing the entire sequence after a genbank parse
    	next if ($feature->primary_tag eq "CDS_span"); 	# these are on strand 0 so should be chucked (or?)
    	next if ($feature->primary_tag eq "intron"); 	# these are simply too ugly to map
    	next if ($feature->primary_tag eq "gene_span");	# these are apparently redundant to the tag "gene"
    	next if ($feature->primary_tag eq "CDS");
    	next if ($feature->primary_tag eq "gene");
    	next if ($feature->can("transcripts"));   # don't map genes (::Gene::GeneStructureI compliant objects)
    	next if ($feature->can("exons"));         # don't map transcripts (::Gene::TranscriptI compliant objects)
    	
    	push @{$self->IndexedFeatureList}, $feature; # push the reference to this feature onto the indexed list
    	
     	my $offset;
       	$self->_check_and_expand_draft_canvas($feature->source_tag);  # checks source, and assigns new offset & color to that source if it is new.  Also expands the canvas & resets scrollbars to accomodate new size
   		$offset = $self->current_offsets->{$feature->source_tag};
		my $FeatureID =  $self->next_id; # get next available index number
	    my $FID = "FID$FeatureID"; # just to remind us that this is now the widget designation not the index number
		$self->_drawFeature($self->DraftMap, $self->DraftCanvas, $offset, $FID, $self->_parse_feature_info($feature, $FID, $offset,'draft'));
	
    	push @MappedIDs, "$FID";

	}  # end of the foreach $feature loop
	
	return @MappedIDs;	

}

sub _mapOntoFinished {

	my ($self, $genes)=@_;
    my @MappedIDs;

    foreach my $gene(@{$genes}) {
        next if (!($gene->can("transcripts")) && ($gene->primary_tag ne "gene"));  # all ::Gene::GeneStructureI objects should have this method, ignore them if they don't
    																				# the problem is that for compliance with SeqIO parsing of genbank files I have to accomodate
    																				# the primary_tag "gene" as well... hopefully this will change one day.
    	push @{$self->IndexedFeatureList}, $gene; # push the reference to this feature onto the indexed list
    	
     	my $offset;
		if ($gene->{SeqCanvas_offset}){             # transcript objects are given this tag as they are loaded up upon SeqCanvas initialization
			($offset) = $gene->{SeqCanvas_offset};
		} else {									# in principle this should never ever happen
			($offset) = 10;  						# but just in case...		
		}

   		my $FeatureID =  $self->next_id; # get next available index number
    	my $pFID = "FID$FeatureID"; # just to remind us that this is now the widget designation not the index number
    	$self->_drawFeature($self->FinishedMap, $self->FinishedCanvas, $offset, $pFID, $self->_parse_feature_info($gene, $pFID, $offset,'finished')); # and map it
    	push @MappedIDs, "$pFID";
	    next if (!($gene->can("transcripts")));     # get out at this point if it is not a GeneStructureI compliant object.
		foreach my $transcript($gene->transcripts){ # take each transcript
			my $offset;
			# the transcripts *should* have been assigned an offset already if we have gone this far, but just in case...
			if ($transcript->{SeqCanvas_offset}){             # transcript objects are given this tag as they are loaded up upon SeqCanvas initialization
				($offset) = $transcript->{SeqCanvas_offset};
			} else {
				next                                          # then something has got totally screwed!
			}
	
			foreach my $exon($transcript->exons){
				my $FeatureID =  $self->next_id; # get next available index number
    			my $FID = "FID$FeatureID"; # just to remind us that this is now the widget designation not the index number
    			$self->_drawFeature($self->FinishedMap, $self->FinishedCanvas, $offset, $FID, $self->_parse_feature_info($exon, $FID, $offset,'finished'), "Child_of_$FID");
			    push @MappedIDs, "$FID";
    			push @{$self->IndexedFeatureList}, $exon; # push the reference to this feature onto the indexed list
			}
			foreach my $promotor($transcript->promoters){
				my $FeatureID =  $self->next_id; # get next available index number
    			my $FID = "FID$FeatureID"; # just to remind us that this is now the widget designation not the index number
    			push @MappedIDs, "$FID";
				push @{$self->IndexedFeatureList}, $promotor; # push the reference to this feature onto the indexed list
				$self->_drawFeature($self->FinishedMap, $self->FinishedCanvas,  $offset, $FID,  $self->_parse_feature_info($promotor, $FID, $offset,'finished'), "Child_of_$FID");
			}
			if ($transcript->poly_A_site){
				my $polyA = $transcript->poly_A_site;
				my $FeatureID =  $self->next_id; # get next available index number
    			my $FID = "FID$FeatureID"; # just to remind us that this is now the widget designation not the index number
    			push @{$self->IndexedFeatureList}, $polyA; # push the reference to this feature onto the indexed list
				$self->_drawFeature($self->FinishedMap, $self->FinishedCanvas, $offset,  $FID, $self->_parse_feature_info($polyA, $FID, $offset,'finished'), "Child_of_$FID");
			    push @MappedIDs, "$FID";
			}	
		}
	}  # end of the foreach $feature loop
	return @MappedIDs;
}

sub _parse_feature_info {
	my ($self, $feature, $FID, $offset,$whichmap) = @_;
	my @tags;
	my $start = $feature->start; # get various useful goodies for mapping
    my $end = $feature->end;
    my $source = $feature->source_tag;
    my $type = $feature->primary_tag;
    my $label;
    if ($feature->has_tag($self->label)){
    	($label) = ($self->label)?$feature->each_tag_value($self->label):undef;  # set the label if it is required and present
    } else {$label = undef}
    if (($feature->primary_tag eq "gene") || ($feature->primary_tag eq "genestructure")) {$source = "gene"}   	
    my $strand = $feature->strand;
    $strand =~ s/\+/1/;                     # these change GFF format strand designations into BioPerl Seq object strand desig.
    $strand =~ s/-$/-1/;                    # But really... BioPerl should adopt GFF formats one day -  The GFF designations are
    $strand =~ s/\./0/;	                    # much more intuitive (IMHO)
    if ($feature->has_tag("id")){push @tags, "DB_ID " . $feature->each_tag_value("id")}  # this is to 'link' this widget to an an external database if desired.
    push @tags, $FID;	# assign that ID to this on-screen widget		
    push @tags, "Source $source";           # push the source so that we can retrieve the offset and color later if necessary
    push @tags, "Strand $strand";
    push @tags, "Type $type";				# this holds the info about what type of Feature it is... comes from Primary tag...
    push @tags, "Canvas $whichmap";			# let the widget know which map it is sitting on
    push @tags, "M_Ftr";					# this is a generic tag to indicate that this is a mapped feature - used to obtain the bounding box for mapped features which then sets the scrollregion
    push @tags, "_SC_start $start";         # add the stop/start/offset to the object itself so that it knows where it is
    push @tags, "_SC_stop $end";            # this info is used to draw the bounding boxes, etc.
    push @tags, "_SC_offset $offset";

    my $color = $self->current_colors->{$source};

    return ($color, $label, $start, $end, $strand, @tags);  # this is formatted to fit perfectly into the _drawFeature routine below

}


sub _drawFeature {
	my ($self, $map, $canvas, $offset, $FID, $color, $label, $start, $end, $strand, @tags ) = @_;

    my @coords;
    	
   	if ($strand eq "-1") {
   		push @coords, [$end, $start];
   		if (!$label){         # if no labels, or if this feature doesn't have the label then map without labelling
   						$map->MapObject(\@coords, '-ataxis' => $offset,
   							'-color' => $color, '-tags' => \@tags);
   		} else {
   			$map->MapObject(\@coords, '-ataxis' => $offset, '-label' => $label, '-labelcolor' => $color,
   							'-color' => $color, '-tags' => \@tags);
   		}
    	   		
   	} else {
   		push @coords, [$start, $end];
   		if (!$label){
   			$map->MapObject(\@coords, '-ataxis' => -$offset,
   							'-color' => $color, '-tags' => \@tags);
   		} else {
   			$map->MapObject(\@coords, '-ataxis' => -$offset, '-label' => $label, '-labelcolor' => $color,
   							'-color' => $color, '-tags' => \@tags);
   		}
   	}

   	$canvas->bind("$FID", '<Button-1>', sub{_selectFeature($self, $canvas, $map, 'single')});       # clicking the left mouse selects a single widget
   	$canvas->bind("$FID", '<Shift-Button-1>', sub{_selectFeature($self, $canvas, $map, 'multi')});  # shift-clicking selects multiple widgets
   	$canvas->bind("$FID", '<Double-Button-1>', sub{_selectFeature($self, $canvas, $map, 'single')});  		# a double-click must be assigned to only
   	$canvas->bind("$FID", '<Shift-Double-Button-1>', sub{_selectFeature($self, $canvas, $map, 'single')});  # one widget, so call with 'single' for both cases
   	$canvas->bind("$FID", '<Enter>', sub{$canvas->dtag("Mouse_over");$canvas->addtag("Mouse_over", "withtag", $FID)});   # mouse-enter over a given feature will add a unique "mouse_over" tag
   	$canvas->bind("$FID", '<Leave>', sub{$canvas->dtag("Mouse_over")});       	# leaving that widget will delete this tag
         									   # This can be examined via a call to selectWithtag("mouse_over")<Movement> event in the
         									   # top-level windowing system
         	
}


=head2 unmapFeatures

 Title    : unmapFeatures
 Usage    : my $FeatureObjsRef = $MapObj->unmapFeatures(\@FeatureIDs)
 Function : to remove mapped features (and SubFeatures!!) from the map display
 Returns  : referenced list of removed $FeatureObj objects;
            note that objects may appear in this list multiple times
            if they appeared in more than one place on the map!

=cut

sub unmapFeatures {
    my ($self, $FeatureIDs) = @_;
    my @Features = @{$FeatureIDs};
    my (@unmappedFeatures);
    if ($#Features == -1) {return \@unmappedFeatures};

    $self->clearSelections;
    foreach my $Feature (@Features){
	
    	$self->DraftCanvas->delete($Feature);       # delete the map widgets
    	$self->FinishedCanvas->delete($Feature);
    	my ($id)= $Feature =~ /FID(.+)/;            # need the id number to get the actual feature object
    	my $unmappedFeature = $self->IndexedFeatureList->[$id]; # get the feature
    	push @unmappedFeatures, $unmappedFeature;     # and prepare to send it back to the caller
    	
    	foreach my $subfeature($self->_getAllSubFeatures($unmappedFeature)){   # now get any and all subfeatures and unmap them
    		my $x = scalar($subfeature);                                    # they are identified by their scalar designations - e.g. Bio::SeqFeature::Generic=HASH(0x89e2fec)
    		my $pos = 0;                                                    # counter to show where we are in the indexed feature list
    		foreach my $indF(@{$self->IndexedFeatureList}){                    # iterate through teh feature list
    			my $y = scalar($indF);                                      # make a scalar from that feature id
    			if ($x eq $y){
    				$self->DraftCanvas->delete("FID$pos");
    				$self->FinishedCanvas->delete("FID$pos");  # if it is the same, then delete that feature
    				push @unmappedFeatures, $self->IndexedFeatureList->[$id]; # get the feature
    				undef $self->IndexedFeatureList->[$pos];	# and remove it from the feature list
    			}
    			++$pos				
        	}
		}
		undef $self->IndexedFeatureList->[$id];                       # delete it from the encapsulated list
	}
    return \@unmappedFeatures
}

=head2 getSelectedIDs

 Title    : getSelectedIDs
 Usage    : $FeatureIDs = $MapObj->getSelectedIDs
 Function : to retrieve the FeatureID's of 
               all currently selected mapped objects
 Returns  : reference to a list of FeatureID's
 Args     : none

=cut

sub getSelectedIDs {
	
	# a special case of getIDsWithTag - just fill in with "selected" and return the result
	my $self = shift;
	my $FeatureListRef = $self->getIDsWithTag(["selected"]);
	return $FeatureListRef;
	
}

=head2 getSelectedTags

 Title   : getSelectedTags
 Usage   : ($FeatureID, $strand, $source, 
	    $type, $canvas [, $DB_ID]) = $MapObj->getSelectedTags
 Returns : FeatureID, Source, Strand, Type (i.e. Primary_tag),
    Canvas ('draft' or 'finished'), 
    and Database_Index (if available).
 Comment : This is to be used for single-selection events only!
 Args    : none		

=cut



sub getSelectedTags {
    my $self = shift;
    my $Dcanvas = $self->DraftCanvas;
    my $Fcanvas = $self->FinishedCanvas;
    my (@selected, $FeatureID, $source, $strand, $type, $canvas, $DB_ID);
    my $widget;
    my $whichmap = "draft";   # set this as the default at the beginning, if the selected feature is on the finished map we will change it
    #check the Draft and Finished canvasses for selected
    @selected = $Dcanvas->find("withtag", "selected");       # find all Widget ID's that have a "selected" tag
    if ((scalar @selected) == 0){
    	@selected = $Fcanvas->find("withtag", "selected");   # if there is nothign on the draft, perhaps there is something on the finished
    	$whichmap = "finished";                              # update our flag
    }
    return if ((scalar @selected) == 0);                     # if not, then get out

    $widget=shift @selected;                                 # get this widget (single widget only!)
	
    my @tags;
    if ($whichmap eq "draft"){@tags = $Dcanvas->gettags($widget)}
    else {@tags = $Fcanvas->gettags($widget)}
    # for each widget, extract all tags associated with that widget
    foreach my $tag(@tags){
	if ($tag =~ /^(FID.+)/) {$FeatureID = $1}
	if ($tag =~ /^Source (.+)/){$source = $1}
	if ($tag =~ /^Strand (.+)/){$strand = $1}
	if ($tag =~ /^Type (.+)/){$type = $1}
	if ($tag =~ /Canvas (.+)/){$canvas = $1}
	if ($tag =~ /^DB_ID (.+)/){$DB_ID = $1}
	
    }
	return ($FeatureID, $strand, $source, $type, $canvas, $DB_ID);   # note that this returns only the values for the last-parsed widget!!
}

=head2 getIDsWithTag

 Title    : getIDsWithTag
 Usage    : $FeatureIDs = $MapObj->getIDsWithTag(\@taglist)
 Function : to retrieve the FeatureID's of all currently selected mapped objects
 Returns  : reference to a list of FeatureID's
 Args     : a reference to a list of tags (see discussion of proper tag format above)

=cut


sub getIDsWithTag {
	my ($self, $whichtags) = @_;
	my @whichtags = @{$whichtags};	
	my $Dcanvas = $self->DraftCanvas;
	my $Fcanvas = $self->FinishedCanvas;
	my (@FeatureIDList, @selected);
	
	if ($#whichtags == -1) {return \@FeatureIDList};           # returns the empty list if no parameters were sent into the routine

	foreach my $whichtag(@whichtags){
    	#first check the Draft canvas for selected
        @selected = $Dcanvas->find("withtag", $whichtag);       # find all Widget ID's that have a "selected" tag
        foreach my $widget(@selected){
        	my @tags = $Dcanvas->gettags($widget);               		# for each widget, extract all tags associated with that widget
        	my ($FeatureID, $strand, $source) = _extractTags(\@tags);   # get just the interesting ones
        	next if (!$FeatureID);    	
        		my $testflag = 0;                                       # this test routine is the result of a two-hour-long god damn frustrating bug-hunt!
        		foreach my $testID(@FeatureIDList){                       # It turns out that when you click on a labelled widget BOTH the widget AND
        			if ($testID eq $FeatureID){$testflag = 1; last}     # the label are considered "selected" as two independant widgets with the same
        		}                                                       # FID number coming from Bio::TkPerl, but different Tk Canvas widget ID's... bastards!
        		if ($testflag == 0){push @FeatureIDList, $FeatureID};     # so to prevent errors elsewhere, stick the ID in the list to be returned to the user
         }                                                              # iffff that ID is unique to the list (i.e. is not the label for an already pushed widget)

         # now do the Finished Canvas
        @selected = $Fcanvas->find("withtag", $whichtag);
        foreach my $widget(@selected){
        	my @tags = $Fcanvas->gettags($widget);
        	my ($FeatureID, $strand, $source) = _extractTags(\@tags);   # stick the id in the list
        	next if (!$FeatureID);
        	my $testflag = 0;
        		foreach my $testID(@FeatureIDList){
        			if ($testID eq $FeatureID){$testflag = "1"; last}
        		}
        		if ($testflag == 0){push @FeatureIDList, $FeatureID};
         }
     }  # end of foreach $whichtag
     return \@FeatureIDList;
}

=head2 getSelectedFeatures

 Title   : getSelectedFeatures
 Usage   : $FeatureHashRef = $MapObj->getSelectedFeatures
 Returns : a reference to a hash where the FeatureID is the key, 
           and the Bio::SeqFeature Object is the value
 Args : none

=cut


sub getSelectedFeatures{
	# this is a special case of getFeaturesWithTag
	# so fill in the "whichtag" with "selected" and return the result

	my $self = shift;
	my $FeatureHashRef = $self->getFeaturesWithTag(["selected"]);
	return $FeatureHashRef;
}

=head2 getFeaturesWithTag

 Title   : getFeaturesWithTag
 Usage   : $FeatureHashRef = $MapObj->getFeaturesWithTag(\@taglist)
 Returns : a reference to a hash where the FeatureID is the
           key, and the Bio::SeqFeature Object is the value
 Args    : reference to a list of valid tags 
           (see discussion of proper tag format)

=cut

sub getFeaturesWithTag {
	my ($self, $whichtags) = @_;
	my @whichtags = @{$whichtags};
	
 	my (%FeatureHash, @selected);
	if ($#whichtags == -1){return \%FeatureHash};   # returns an empty hash if there were no parameters sent
	
	foreach my $whichtag(@whichtags){	
    	my $Dcanvas = $self->DraftCanvas;
    	my $Fcanvas = $self->FinishedCanvas;
        @selected = $Dcanvas->find("withtag", $whichtag);       # find all DRAFT Widget ID's that have a "selected" tag
        foreach my $widget(@selected){
        	my @tags = $Dcanvas->gettags($widget);               		# for each widget, extract all tags associated with that widget
        	my ($FeatureID, $strand, $source) = _extractTags(\@tags);   # get just the interesting ones
        	$FeatureID =~ /FID(.+)/;
        	next if (!$FeatureID);
        	my $FeatureIndex = $1;
        	my $feature = $self->IndexedFeatureList->[$FeatureIndex];   # extract this Bio::Feature object from the indexed list
        	$FeatureHash{"$FeatureID"} = $feature;                 # stick it in the hash to be returned to the user
         }
        @selected = $Fcanvas->find("withtag", $whichtag);      # find all FINISHED Widget ID's that have a "selected" tag
        foreach my $widget(@selected){
        	my @tags = $Fcanvas->gettags($widget);
        	my ($FeatureID, $strand, $source) = _extractTags(\@tags);
        	$FeatureID =~ /FID(.+)/;
        	next if (!$FeatureID);
        	my $FeatureIndex = $1;                                       # extract the digit portion of this, which is a pointer to the feature list
        	my $feature = $self->IndexedFeatureList->[$FeatureIndex];   # extract this Bio::Feature object from the list
        	$FeatureHash{$FeatureID} = $feature;                         # assign it in a $hash{FIDxxx} = $FeatureObject
         }                                                               # N.B. because of the hash structure we don't need to worry about this feature/label duplication
     }	# end of foreach $whichtag                                       # that arose in getIDsWithTag, as it simply overwrites them.
     return \%FeatureHash;                                           # return the hash
}

=pod

=head2 clearSelections

 Title    : clearSelections
 Usage    : $MapObj->clearSelections
 Function : Clear all selection boxes and "selected" status of all Features.
 Returns  : nothing
 Args     : none


=cut
sub clearSelections {
	my $self = shift;
    $self->DraftCanvas->delete('selection_box');   #  we delete all reference to selected stuff on both maps
    $self->DraftCanvas->dtag('selected');          # 			"
    $self->FinishedCanvas->delete('selection_box');# 			"
    $self->FinishedCanvas->dtag('selected');        # 			"
}

=pod

=head2 selectFeatures

 Title    : selectFeatures
 Usage    : $MapObj->selectFeatures(\@FeatureIDs)
 Function : "select" all Features with @FeatureID id's
 Args     : @FeatureIDs - a list of valid
            FeatureIDs (of the form FIDnnn where nnn is a unique integer)

=cut


sub selectFeatures {
	my $self = shift @_;
	my @FeatureIDs = @{shift @_};
	return if ($#FeatureIDs == -1);
	
	foreach my $FeatureID(@FeatureIDs) {
		$self->DraftCanvas->addtag('now_current', 'withtag', $FeatureID);    		# the _selectFeature routine looks for widgets that are 'current' and boxes them
		_selectFeature ($self, $self->DraftCanvas, $self->DraftMap, 'multi'); 	# call the routine in multi-mode
		$self->FinishedCanvas->addtag('now_current', 'withtag', $FeatureID);    		# the _selectFeature routine looks for widgets that are 'current' and boxes them
		_selectFeature ($self, $self->FinishedCanvas, $self->FinishedMap, 'multi'); 	# call the routine in multi-mode
	
	}
}

=pod

=head2 selectWithTag

 Title    : selectWithTag
 Usage    : $MapObj->selectWithTag(\@tag_list [,'draft'|'finished'])
 Function : "select" all features which have any of @tag_list tags.
 Args     : @taglist, and optional 'draft' or 'finished' which map

=cut

sub selectWithTag {	
	my $self = shift @_;
	my @tags = @{shift @_};
	my $whichmap = shift @_;
	return if ($#tags == -1);
	
	foreach my $tag(@tags) {
		if (defined $whichmap && $whichmap eq 'finished'){
    		my @widgets = $self->FinishedCanvas->find("withtag", $tag);
    		foreach my $widget(@widgets){
    			$self->FinishedCanvas->addtag('now_current', 'withtag', $widget);    		# the _selectFeature routine looks for widgets that are 'now_current' and boxes them
    			_selectFeature ($self, $self->FinishedCanvas, $self->FinishedMap, 'multi'); 	# call the routine in multi-mode
    		}
		}
		elsif (defined $whichmap && $whichmap eq 'draft'){
    		my @widgets = $self->DraftCanvas->find("withtag", $tag);
    		foreach my $widget(@widgets){
    			if (! $self->_isLabel($widget)){
        			$self->DraftCanvas->addtag('now_current', 'withtag', $widget);    		# the _selectFeature routine looks for widgets that are 'now_current' and boxes them
        			_selectFeature ($self, $self->DraftCanvas, $self->DraftMap, 'multi'); 	# call the routine in multi-mode
				}
    		}
		} else {
    		my @widgets = $self->FinishedCanvas->find("withtag", $tag);
    		push @widgets, $self->DraftCanvas->find("withtag", $tag);
    		foreach my $widget(@widgets){
    			if (! $self->_isLabel($widget)){
        			$self->FinishedCanvas->addtag('now_current', 'withtag', $widget);    		# the _selectFeature routine looks for widgets that are 'now_current' and boxes them
        			_selectFeature ($self, $self->FinishedCanvas, $self->FinishedMap, 'multi'); 	# call the routine in multi-mode
        			$self->DraftCanvas->addtag('now_current', 'withtag', $widget);    		# the _selectFeature routine looks for widgets that are 'now_current' and boxes them
        			_selectFeature ($self, $self->DraftCanvas, $self->DraftMap, 'multi'); 	# call the routine in multi-mode
    			}
    		}
		}   	
	}
}

=pod

=head2 recolorWithTag

 Title    : recolorWithTag
 Usage    : $MapObj->recolorWithTag('#XXXXXX'|'default', 'draft'|'finished', \@tag_list)
 Function : change the color of mapped objects having one of @tag_list tags.
 Returns  : nothing
 Args     :
	First arg:hex-reference to an RGB color value, or 'default'.
	Second arg: the canvas ('draft', or 'finished')
	Third arg: a referenced list of tags.

=cut

sub recolorWithTag {
    my ($self, $color, $whichmap, $tagsref) = @_;
    my @tags = @{$tagsref};
    return if ($#tags == -1);
    if ($whichmap eq 'draft'){
    	foreach my $tag(@tags) {
	    if ($color eq "default"){
		my @thesetags = $self->DraftCanvas->gettags($tag); # extract tags
		# specifially to obtain 'source'
		my ($ID, $strand, $source) = _extractTags(\@thesetags);      
		# get the color associated with 'source'		
		my $thiscolor = $self->current_colors->{$source};
                # assign that color to the widget
		$self->DraftCanvas->itemconfigure($tag, -fill => $thiscolor); 
	    } else {
                # assign that color to the widget
                $self->DraftCanvas->itemconfigure($tag, -fill => $color); 
	    }	
    	}
    }
    elsif ($whichmap eq 'finished') {
    	foreach my $tag(@tags) {
	    if ($color eq "default"){
		# extract tags
		my @thesetags = $self->FinishedCanvas->gettags($tag); 
                # specifially to obtain 'source'
		my ($ID, $strand, $source) = _extractTags(\@thesetags);	
                # get the color associated with 'source
		my $thiscolor = $self->current_colors->{$source}; 
                # assign that color to the widget
		$self->FinishedCanvas->itemconfigure($tag, -fill => $thiscolor); 
	    } else {
                # assign that color to the widget
		$self->FinishedCanvas->itemconfigure($tag, -fill => $color); 
	    }	
	}
    } else {
	print "No known map-type was specified in the call to Recolor",
	" - must be either 'draft' or 'finished'"; 
    }   
}

=pod

=head2 assignCustomColors

 Title    : assignCustomColors
 Usage    : $MapObj->assignCustomColors($top)
 Function : change the default map-color for a selected widgets "Source" tag.
 Returns  : nothing
 Args     : a reference to a Tk::MainWindow object (new or existing).

=cut

sub assignCustomColors {
    my ($self, $top) = @_;
    return if (!$top);
    return if (!ref($top) =~ /MainWindow/);
    my ($FID, $strand, $source, $DB_ID) = $self->getSelectedTags;
    return if (!$source);
    my $cedit;
    $cedit = $top->ColorEditor(-title => "chose a new color for the $source features",
			       -command => 
			       sub {
				   my $color = $_[1];
				   $self->current_colors->{$source} = $color;
				
				   $self->recolorWithTag('default', 'draft', ["Source $source"]);
				   $self->recolorWithTag('default', 'finished', ["Source $source"]);
				   $cedit->destroy;
			       } );

$cedit->delete_menu_item(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15, 16, 17);
$cedit->Show;
$cedit->add_menu_item($source);

}

=head2 is_draft_feature

 Title    : is_draft_feature
 Usage    : $result = $MapObj->is_draft_feature($FeatureID)
 Function : check if a $FeatureID is on the draft (white) map.
 Returns  : 1 for true, undef for false
 Args     : the FeatureID you are querying

=cut


sub is_draft_feature {  # this simply returns 1 (true) or undef (false) if the passed widgetID is on the draft map
	my ($MapObj, $FID) = @_;
	return if (!$FID);
	my $result;
	my @WidgetTags = $MapObj->DraftCanvas->gettags("$FID");
	if (@WidgetTags){$result = 1}
	return $result;
}


=pod

=head2 is_finished_feature

 Title    : is_finished_feature
 Usage    : $result = $MapObj->is_finished_feature($FeatureID)
 Function : check if $FeatureID is on the finished (blue) map.
 Returns  : 1 for true, undef for false
 Args     : the FeatureID you are querying

=cut

sub is_finished_feature {
    my ($MapObj, $FID) = @_;
    return if (!$FID);
    my $result;
    my @WidgetTags = $MapObj->FinishedCanvas->gettags("$FID");
    if (@WidgetTags){$result = 1}
    return $result;
}	

=pod

=head1 EVENTS

The SeqCanvas both internally responds to mouse events, and sets "tags" on the mapped feature in response to mouse events
such that the user can "trap" these events in the top-level windowing system and evaluate which mapped feature the user was
manupulating.

=head2 Mouse-Click

Clicking or shift-Clicking the left mouse button
over a mapped feature causes the feature(s) to become "selected".
A selected object is displayed on the screen with a black box surrounding
the object, and the object becomes tagged with a testable tag "selected"
(use the getSelectedFeatures or getSelectedIDs to retrieve additional information
about this object)

=head2 Mouse-Double-Click

Both Double-clicking and Shift Double-Clicking
the mouse over an object selects that (single) mapped feature. All
other features become unselected.

=head2 Mouse-Click and Drag

Used to select multiple objects. Any object touched by the bounding box will be included in the selection.

=head2 Mouse-Over

As the mouse pointer enters the mapped widget, the tag "Mouse_over" is added to this object. information about this
object could be retrieved by, for example, calling the getIDsWithTag(["Mouse_over"])
method. This tag is removed when the mouse pointer leaves the mapped-feature
space. Bind the <Movement> event in the top-level windowing
system to track the mouse movements if you wish to monitor the Mouse-Over
widget events.

=cut

1;
